# 企业级删除策略与用户表设计指南

## 目录
1. [删除策略对比分析](#删除策略对比分析)
2. [当前问题分析](#当前问题分析)
3. [软删除 vs 硬删除](#软删除-vs-硬删除)
4. [真实企业生产环境删除逻辑](#真实企业生产环境删除逻辑)
5. [用户表企业级设计](#用户表企业级设计)
6. [完整实现方案](#完整实现方案)

---

## 一、删除策略对比分析

### 1.1 当前问题分析

**问题描述：**
- 删除员工后，根据 ID 查询会抛出 `EntityNotFoundException`
- 没有友好的错误提示
- 删除操作不可逆（硬删除）

**当前代码问题：**
```java
// EmployeeServiceImpl.java
@Override
public void delete(Long id) {
    if (!employeeRepository.existsById(id)) {
        throw new EntityNotFoundException("员工不存在，ID: " + id);
    }
    employeeRepository.deleteById(id);
}

@Override
public EmployeeResponse findById(Long id) {
    Employee employee = employeeRepository.findById(id)
            .orElseThrow(() -> new EntityNotFoundException("员工不存在，ID: " + id));
    return EmployeeResponse.from(employee);
}
```

**问题点：**
1. 删除后查询会报错，用户体验差
2. 没有区分"不存在"和"已删除"的状态
3. 数据无法恢复
4. 无法追踪删除历史

---

## 二、软删除 vs 硬删除

### 2.1 硬删除（Hard Delete）

**定义：** 直接从数据库中物理删除记录

**优点：**
- ✅ 数据库空间占用小
- ✅ 查询性能好（不需要过滤已删除记录）
- ✅ 实现简单

**缺点：**
- ❌ 数据无法恢复
- ❌ 无法追踪删除历史
- ❌ 关联数据可能产生外键约束问题
- ❌ 审计困难

**适用场景：**
- 临时数据、缓存数据
- 日志数据（定期清理）
- 测试数据

### 2.2 软删除（Soft Delete）

**定义：** 通过标记字段（如 `deleted`、`is_deleted`）标记记录为已删除，不实际删除数据

**优点：**
- ✅ 数据可恢复
- ✅ 可以追踪删除历史（谁删除、何时删除）
- ✅ 审计友好
- ✅ 关联数据安全（不会破坏外键关系）
- ✅ 可以统计删除数据

**缺点：**
- ❌ 数据库空间占用增加
- ❌ 查询需要过滤已删除记录（性能略低）
- ❌ 实现相对复杂

**适用场景：**
- ✅ **用户数据**（用户、员工等）
- ✅ **订单数据**（订单、交易记录）
- ✅ **重要业务数据**（合同、文档）
- ✅ **需要审计的数据**

### 2.3 对比总结

| 对比项 | 硬删除 | 软删除 |
|--------|--------|--------|
| **数据恢复** | ❌ 不可恢复 | ✅ 可恢复 |
| **性能** | ✅ 更好 | ⚠️ 略差（需过滤） |
| **审计** | ❌ 困难 | ✅ 友好 |
| **实现复杂度** | ✅ 简单 | ⚠️ 中等 |
| **数据库空间** | ✅ 节省 | ❌ 占用更多 |
| **关联数据安全** | ❌ 可能有问题 | ✅ 安全 |
| **企业级应用** | ❌ 不推荐 | ✅ **强烈推荐** |

---

## 三、真实企业生产环境删除逻辑

### 3.1 企业级删除策略（推荐）

**核心原则：**
1. **重要数据使用软删除**
2. **提供删除恢复功能**
3. **记录删除操作日志**
4. **定期清理过期数据**

### 3.2 典型的企业级删除流程

#### 方案 A：软删除 + 删除时间戳（推荐）

```sql
-- 员工表结构
CREATE TABLE employee (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    -- ... 其他字段
    
    -- 软删除字段
    deleted BOOLEAN DEFAULT FALSE,           -- 是否已删除
    deleted_at TIMESTAMP,                    -- 删除时间
    deleted_by BIGINT,                       -- 删除人ID（关联用户表）
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP,
    created_by BIGINT,                       -- 创建人ID
    updated_by BIGINT                        -- 更新人ID
);

-- 创建索引（提升查询性能）
CREATE INDEX idx_employee_deleted ON employee(deleted) WHERE deleted = FALSE;
```

#### 方案 B：状态字段（更灵活）

```sql
CREATE TABLE employee (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    -- ... 其他字段
    
    -- 状态字段（更灵活，可以扩展更多状态）
    status VARCHAR(20) DEFAULT 'ACTIVE',     -- ACTIVE, DELETED, SUSPENDED, ARCHIVED
    status_changed_at TIMESTAMP,
    status_changed_by BIGINT,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP
);
```

### 3.3 企业级删除操作流程

```
1. 用户点击删除
   ↓
2. 检查关联数据（是否有订单、合同等）
   ↓
3. 执行软删除（更新 deleted = true）
   ↓
4. 记录删除日志（谁删除、何时删除、原因）
   ↓
5. 发送通知（可选：通知相关人员）
   ↓
6. 返回成功（不报错）
```

### 3.4 查询时的处理逻辑

```java
// ✅ 正确：查询时自动过滤已删除记录
public EmployeeResponse findById(Long id) {
    Employee employee = employeeRepository.findByIdAndDeletedFalse(id)
            .orElseThrow(() -> new EntityNotFoundException("员工不存在或已删除，ID: " + id));
    return EmployeeResponse.from(employee);
}

// ✅ 如果需要查询已删除的记录（管理员功能）
public EmployeeResponse findByIdIncludeDeleted(Long id) {
    Employee employee = employeeRepository.findById(id)
            .orElseThrow(() -> new EntityNotFoundException("员工不存在，ID: " + id));
    
    if (employee.getDeleted()) {
        // 返回时标记为已删除
        // 或者抛出特殊异常
    }
    return EmployeeResponse.from(employee);
}
```

---

## 四、用户表企业级设计

### 4.1 用户表核心字段设计

#### 基础字段

```sql
CREATE TABLE user_account (
    -- 主键
    id BIGSERIAL PRIMARY KEY,
    
    -- 业务唯一标识（对外暴露，不暴露自增ID）
    uid VARCHAR(32) UNIQUE NOT NULL,        -- UUID 或 雪花算法ID
    
    -- 登录凭证
    username VARCHAR(50) UNIQUE NOT NULL,    -- 用户名（唯一）
    password VARCHAR(255) NOT NULL,           -- 密码（BCrypt 加密）
    email VARCHAR(100) UNIQUE,               -- 邮箱（唯一，可选）
    phone VARCHAR(20) UNIQUE,                 -- 手机号（唯一，可选）
    
    -- 用户信息
    nickname VARCHAR(100),                    -- 昵称
    avatar_url VARCHAR(500),                  -- 头像URL
    gender VARCHAR(10),                       -- 性别：MALE, FEMALE, OTHER
    birthday DATE,                            -- 生日
    
    -- 状态管理
    status VARCHAR(20) DEFAULT 'ACTIVE',   -- ACTIVE, INACTIVE, SUSPENDED, DELETED
    enabled BOOLEAN DEFAULT TRUE,             -- 账户是否启用
    account_non_locked BOOLEAN DEFAULT TRUE,  -- 账户是否锁定
    account_non_expired BOOLEAN DEFAULT TRUE, -- 账户是否过期
    credentials_non_expired BOOLEAN DEFAULT TRUE, -- 凭证是否过期
    
    -- 安全相关
    last_login_time TIMESTAMP,               -- 最后登录时间
    last_login_ip VARCHAR(50),                -- 最后登录IP
    login_count INT DEFAULT 0,               -- 登录次数
    password_changed_at TIMESTAMP,            -- 密码修改时间
    password_reset_token VARCHAR(255),        -- 密码重置令牌
    password_reset_expires_at TIMESTAMP,     -- 密码重置过期时间
    
    -- 软删除
    deleted BOOLEAN DEFAULT FALSE,
    deleted_at TIMESTAMP,
    deleted_by BIGINT,
    
    -- 审计字段
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP,
    created_by BIGINT,
    updated_by BIGINT,
    
    -- 版本控制（乐观锁）
    version INT DEFAULT 0
);

-- 索引
CREATE INDEX idx_user_uid ON user_account(uid);
CREATE INDEX idx_user_username ON user_account(username);
CREATE INDEX idx_user_email ON user_account(email) WHERE email IS NOT NULL;
CREATE INDEX idx_user_phone ON user_account(phone) WHERE phone IS NOT NULL;
CREATE INDEX idx_user_status ON user_account(status);
CREATE INDEX idx_user_deleted ON user_account(deleted) WHERE deleted = FALSE;
```

### 4.2 UID 生成策略

#### 方案 A：UUID（推荐用于分布式系统）

```java
// 优点：全局唯一，无需中心化生成
// 缺点：较长（36字符），无序
String uid = UUID.randomUUID().toString().replace("-", "");
// 结果：32位字符串，如：a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6
```

#### 方案 B：雪花算法（推荐用于单机/小规模分布式）

```java
// 优点：有序、短（19位数字）、性能好
// 缺点：需要配置机器ID和数据中心ID
// 可以使用现成的库：Hutool、Twitter Snowflake
long uid = snowflakeIdGenerator.nextId();
// 结果：19位数字，如：1234567890123456789
```

#### 方案 C：自定义规则（根据业务需求）

```java
// 例如：USER + 时间戳 + 随机数
String uid = "USER" + System.currentTimeMillis() + RandomUtils.nextInt(1000, 9999);
// 结果：USER17040672000001234
```

### 4.3 用户表 CRUD 逻辑设计

#### 4.3.1 创建用户（Create）

**业务逻辑：**
```
1. 验证用户名、邮箱、手机号唯一性
2. 密码加密（BCrypt）
3. 生成 UID
4. 设置默认状态（ACTIVE）
5. 记录创建人、创建时间
6. 返回用户信息（不返回密码）
```

**实现要点：**
```java
public UserResponse create(UserCreateRequest request) {
    // 1. 验证唯一性
    if (userRepository.existsByUsername(request.username())) {
        throw new BusinessException("用户名已存在");
    }
    if (request.email() != null && userRepository.existsByEmail(request.email())) {
        throw new BusinessException("邮箱已存在");
    }
    
    // 2. 创建用户
    User user = new User();
    user.setUid(generateUid());  // 生成 UID
    user.setUsername(request.username());
    user.setPassword(passwordEncoder.encode(request.password()));
    user.setEmail(request.email());
    user.setStatus(UserStatus.ACTIVE);
    user.setEnabled(true);
    
    // 3. 设置审计字段
    user.setCreatedBy(getCurrentUserId());
    user.setCreatedAt(LocalDateTime.now());
    
    // 4. 保存
    User saved = userRepository.save(user);
    
    // 5. 返回（不包含密码）
    return UserResponse.from(saved);
}
```

#### 4.3.2 查询用户（Read）

**查询场景：**

1. **根据 ID 查询（内部使用）**
```java
public UserResponse findById(Long id) {
    User user = userRepository.findByIdAndDeletedFalse(id)
            .orElseThrow(() -> new EntityNotFoundException("用户不存在，ID: " + id));
    return UserResponse.from(user);
}
```

2. **根据 UID 查询（对外暴露）**
```java
public UserResponse findByUid(String uid) {
    User user = userRepository.findByUidAndDeletedFalse(uid)
            .orElseThrow(() -> new EntityNotFoundException("用户不存在，UID: " + uid));
    return UserResponse.from(user);
}
```

3. **根据用户名查询（登录用）**
```java
public User findByUsername(String username) {
    return userRepository.findByUsernameAndDeletedFalse(username)
            .orElseThrow(() -> new EntityNotFoundException("用户名不存在"));
}
```

4. **分页查询（列表）**
```java
public Page<UserResponse> listUsers(int page, int size, String keyword) {
    Pageable pageable = PageRequest.of(page, size);
    Specification<User> spec = buildSpecification(keyword);  // 构建查询条件
    Page<User> users = userRepository.findAll(spec, pageable);
    return users.map(UserResponse::from);
}

private Specification<User> buildSpecification(String keyword) {
    return (root, query, cb) -> {
        List<Predicate> predicates = new ArrayList<>();
        
        // 只查询未删除的
        predicates.add(cb.equal(root.get("deleted"), false));
        
        // 关键词搜索（用户名、邮箱、昵称）
        if (keyword != null && !keyword.isBlank()) {
            Predicate usernameLike = cb.like(root.get("username"), "%" + keyword + "%");
            Predicate emailLike = cb.like(root.get("email"), "%" + keyword + "%");
            Predicate nicknameLike = cb.like(root.get("nickname"), "%" + keyword + "%");
            predicates.add(cb.or(usernameLike, emailLike, nicknameLike));
        }
        
        return cb.and(predicates.toArray(new Predicate[0]));
    };
}
```

#### 4.3.3 更新用户（Update）

**业务逻辑：**
```
1. 查询用户（确保存在且未删除）
2. 验证唯一性（如果修改了用户名、邮箱等）
3. 更新字段
4. 记录更新人、更新时间
5. 更新版本号（乐观锁）
```

**实现要点：**
```java
public UserResponse update(Long id, UserUpdateRequest request) {
    // 1. 查询用户
    User user = userRepository.findByIdAndDeletedFalse(id)
            .orElseThrow(() -> new EntityNotFoundException("用户不存在，ID: " + id));
    
    // 2. 验证唯一性（如果修改了用户名）
    if (request.username() != null && !request.username().equals(user.getUsername())) {
        if (userRepository.existsByUsername(request.username())) {
            throw new BusinessException("用户名已存在");
        }
        user.setUsername(request.username());
    }
    
    // 3. 更新其他字段
    if (request.email() != null) {
        user.setEmail(request.email());
    }
    if (request.nickname() != null) {
        user.setNickname(request.nickname());
    }
    // ... 其他字段
    
    // 4. 设置审计字段
    user.setUpdatedBy(getCurrentUserId());
    user.setUpdatedAt(LocalDateTime.now());
    user.setVersion(user.getVersion() + 1);  // 乐观锁
    
    // 5. 保存
    User updated = userRepository.save(user);
    return UserResponse.from(updated);
}
```

#### 4.3.4 删除用户（Delete）

**软删除实现：**
```java
public void delete(Long id) {
    // 1. 查询用户
    User user = userRepository.findByIdAndDeletedFalse(id)
            .orElseThrow(() -> new EntityNotFoundException("用户不存在，ID: " + id));
    
    // 2. 检查关联数据（可选）
    if (hasRelatedData(user.getId())) {
        throw new BusinessException("用户存在关联数据，无法删除");
    }
    
    // 3. 软删除
    user.setDeleted(true);
    user.setDeletedAt(LocalDateTime.now());
    user.setDeletedBy(getCurrentUserId());
    user.setStatus(UserStatus.DELETED);
    
    // 4. 保存
    userRepository.save(user);
    
    // 5. 记录删除日志（可选）
    auditLogService.logDelete("USER", user.getId(), getCurrentUserId());
}
```

**硬删除实现（不推荐，仅用于特殊场景）：**
```java
public void hardDelete(Long id) {
    // 仅管理员可以硬删除
    if (!isAdmin()) {
        throw new ForbiddenException("无权限执行硬删除");
    }
    
    User user = userRepository.findById(id)
            .orElseThrow(() -> new EntityNotFoundException("用户不存在，ID: " + id));
    
    // 先记录日志
    auditLogService.logHardDelete("USER", user.getId(), getCurrentUserId());
    
    // 再删除
    userRepository.delete(user);
}
```

#### 4.3.5 恢复用户（Restore）

```java
public void restore(Long id) {
    // 1. 查询已删除的用户
    User user = userRepository.findById(id)
            .orElseThrow(() -> new EntityNotFoundException("用户不存在，ID: " + id));
    
    if (!user.getDeleted()) {
        throw new BusinessException("用户未被删除，无需恢复");
    }
    
    // 2. 恢复
    user.setDeleted(false);
    user.setDeletedAt(null);
    user.setDeletedBy(null);
    user.setStatus(UserStatus.ACTIVE);
    user.setUpdatedBy(getCurrentUserId());
    user.setUpdatedAt(LocalDateTime.now());
    
    // 3. 保存
    userRepository.save(user);
    
    // 4. 记录恢复日志
    auditLogService.logRestore("USER", user.getId(), getCurrentUserId());
}
```

---

## 五、完整实现方案

### 5.1 员工表软删除改造

#### 步骤 1：数据库迁移

```sql
-- 添加软删除字段
ALTER TABLE employee 
ADD COLUMN deleted BOOLEAN DEFAULT FALSE,
ADD COLUMN deleted_at TIMESTAMP,
ADD COLUMN deleted_by BIGINT,
ADD COLUMN created_by BIGINT,
ADD COLUMN updated_by BIGINT;

-- 创建索引
CREATE INDEX idx_employee_deleted ON employee(deleted) WHERE deleted = FALSE;

-- 更新现有数据
UPDATE employee SET deleted = FALSE WHERE deleted IS NULL;
```

#### 步骤 2：实体类改造

```java
@Entity
@Table(name = "employee")
public class Employee {
    // ... 现有字段
    
    @Column(name = "deleted", nullable = false)
    private Boolean deleted = false;
    
    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;
    
    @Column(name = "deleted_by")
    private Long deletedBy;
    
    @Column(name = "created_by")
    private Long createdBy;
    
    @Column(name = "updated_by")
    private Long updatedBy;
}
```

#### 步骤 3：Repository 改造

```java
public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    // 查询未删除的记录
    Optional<Employee> findByIdAndDeletedFalse(Long id);
    
    // 查询所有未删除的记录
    List<Employee> findAllByDeletedFalse();
    
    // 分页查询未删除的记录
    Page<Employee> findAllByDeletedFalse(Pageable pageable);
    
    // 检查是否存在（未删除）
    boolean existsByIdAndDeletedFalse(Long id);
}
```

#### 步骤 4：Service 改造

```java
@Override
public EmployeeResponse findById(Long id) {
    Employee employee = employeeRepository.findByIdAndDeletedFalse(id)
            .orElseThrow(() -> new EntityNotFoundException("员工不存在或已删除，ID: " + id));
    return EmployeeResponse.from(employee);
}

@Override
public void delete(Long id) {
    Employee employee = employeeRepository.findByIdAndDeletedFalse(id)
            .orElseThrow(() -> new EntityNotFoundException("员工不存在或已删除，ID: " + id));
    
    // 软删除
    employee.setDeleted(true);
    employee.setDeletedAt(LocalDateTime.now());
    employee.setDeletedBy(getCurrentUserId());  // 从 SecurityContext 获取
    
    employeeRepository.save(employee);
}

// 新增：恢复功能
public void restore(Long id) {
    Employee employee = employeeRepository.findById(id)
            .orElseThrow(() -> new EntityNotFoundException("员工不存在，ID: " + id));
    
    if (!employee.getDeleted()) {
        throw new BusinessException("员工未被删除，无需恢复");
    }
    
    employee.setDeleted(false);
    employee.setDeletedAt(null);
    employee.setDeletedBy(null);
    employee.setUpdatedBy(getCurrentUserId());
    
    employeeRepository.save(employee);
}
```

### 5.2 异常处理优化

#### 统一异常处理

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(EntityNotFoundException.class)
    public Result<Void> handleEntityNotFound(EntityNotFoundException e) {
        return Result.error(404, e.getMessage());
    }
    
    @ExceptionHandler(BusinessException.class)
    public Result<Void> handleBusinessException(BusinessException e) {
        return Result.error(400, e.getMessage());
    }
    
    @ExceptionHandler(Exception.class)
    public Result<Void> handleException(Exception e) {
        log.error("系统异常", e);
        return Result.error(500, "系统异常，请稍后重试");
    }
}
```

### 5.3 查询优化建议

#### 使用 JPA Specification（推荐）

```java
public interface EmployeeRepository extends JpaRepository<Employee, Long>, JpaSpecificationExecutor<Employee> {
    // 继承 JpaSpecificationExecutor 以支持动态查询
}

// Service 中使用
public List<EmployeeResponse> search(String keyword, Boolean includeDeleted) {
    Specification<Employee> spec = (root, query, cb) -> {
        List<Predicate> predicates = new ArrayList<>();
        
        // 根据参数决定是否包含已删除的记录
        if (!Boolean.TRUE.equals(includeDeleted)) {
            predicates.add(cb.equal(root.get("deleted"), false));
        }
        
        // 关键词搜索
        if (keyword != null && !keyword.isBlank()) {
            Predicate nameLike = cb.like(root.get("name"), "%" + keyword + "%");
            Predicate deptLike = cb.like(root.get("department"), "%" + keyword + "%");
            predicates.add(cb.or(nameLike, deptLike));
        }
        
        return cb.and(predicates.toArray(new Predicate[0]));
    };
    
    List<Employee> employees = employeeRepository.findAll(spec);
    return employees.stream().map(EmployeeResponse::from).toList();
}
```

---

## 六、企业级最佳实践总结

### 6.1 删除策略选择

| 数据类型 | 推荐策略 | 原因 |
|---------|---------|------|
| **用户/员工** | 软删除 | 重要数据，需要审计 |
| **订单/交易** | 软删除 | 财务数据，不可丢失 |
| **文档/合同** | 软删除 | 法律依据，需要保留 |
| **日志数据** | 硬删除 | 定期清理，节省空间 |
| **缓存数据** | 硬删除 | 临时数据，可重新生成 |

### 6.2 实现要点检查清单

- [x] ✅ 添加软删除字段（deleted, deleted_at, deleted_by）
- [x] ✅ 创建索引优化查询性能
- [x] ✅ Repository 方法过滤已删除记录
- [x] ✅ Service 层实现软删除逻辑
- [x] ✅ 提供恢复功能（可选）
- [x] ✅ 统一异常处理
- [ ] ✅ 记录删除日志（可选）
- [ ] ✅ 定期清理过期数据（可选）

### 6.3 性能优化建议

1. **索引优化**
   ```sql
   -- 部分索引（只索引未删除的记录）
   CREATE INDEX idx_employee_deleted ON employee(deleted) WHERE deleted = FALSE;
   ```

2. **查询优化**
   ```java
   // ✅ 好：使用索引字段查询
   findByDeletedFalse()
   
   // ❌ 差：全表扫描
   findAll().stream().filter(e -> !e.getDeleted())
   ```

3. **定期清理**
   ```sql
   -- 定期清理超过1年的已删除数据（可选）
   DELETE FROM employee 
   WHERE deleted = TRUE 
   AND deleted_at < NOW() - INTERVAL '1 year';
   ```

---

## 七、参考实现代码模板

### 7.1 员工实体类（完整版）

```java
@Entity
@Table(name = "employee")
@Data
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private String gender;
    private Integer age;
    private String department;
    private String position;
    
    @Column(name = "hire_date")
    private LocalDate hireDate;
    
    private BigDecimal salary;
    
    // 软删除字段
    @Column(name = "deleted", nullable = false)
    private Boolean deleted = false;
    
    @Column(name = "deleted_at")
    private LocalDateTime deletedAt;
    
    @Column(name = "deleted_by")
    private Long deletedBy;
    
    // 审计字段
    @Column(name = "created_at")
    private LocalDateTime createdAt = LocalDateTime.now();
    
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @Column(name = "created_by")
    private Long createdBy;
    
    @Column(name = "updated_by")
    private Long updatedBy;
    
    @PreUpdate
    public void onUpdate() {
        this.updatedAt = LocalDateTime.now();
    }
}
```

### 7.2 Repository 接口（完整版）

```java
public interface EmployeeRepository extends JpaRepository<Employee, Long>, JpaSpecificationExecutor<Employee> {
    // 基础查询（过滤已删除）
    Optional<Employee> findByIdAndDeletedFalse(Long id);
    List<Employee> findAllByDeletedFalse();
    Page<Employee> findAllByDeletedFalse(Pageable pageable);
    boolean existsByIdAndDeletedFalse(Long id);
    
    // 按部门查询（过滤已删除）
    List<Employee> findByDepartmentAndDeletedFalse(String department);
    
    // 按姓名查询（过滤已删除）
    List<Employee> findByNameContainingIgnoreCaseAndDeletedFalse(String name);
    
    // 查询已删除的记录（管理员功能）
    List<Employee> findAllByDeletedTrue();
    Optional<Employee> findByIdAndDeletedTrue(Long id);
}
```

### 7.3 Service 实现（完整版）

```java
@Service
@Transactional
public class EmployeeServiceImpl implements EmployeeService {
    
    private final EmployeeRepository employeeRepository;
    
    @Override
    public EmployeeResponse findById(Long id) {
        Employee employee = employeeRepository.findByIdAndDeletedFalse(id)
                .orElseThrow(() -> new EntityNotFoundException("员工不存在或已删除，ID: " + id));
        return EmployeeResponse.from(employee);
    }
    
    @Override
    public void delete(Long id) {
        Employee employee = employeeRepository.findByIdAndDeletedFalse(id)
                .orElseThrow(() -> new EntityNotFoundException("员工不存在或已删除，ID: " + id));
        
        // 软删除
        employee.setDeleted(true);
        employee.setDeletedAt(LocalDateTime.now());
        employee.setDeletedBy(getCurrentUserId());
        
        employeeRepository.save(employee);
    }
    
    public void restore(Long id) {
        Employee employee = employeeRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("员工不存在，ID: " + id));
        
        if (!employee.getDeleted()) {
            throw new BusinessException("员工未被删除，无需恢复");
        }
        
        employee.setDeleted(false);
        employee.setDeletedAt(null);
        employee.setDeletedBy(null);
        employee.setUpdatedBy(getCurrentUserId());
        employee.setUpdatedAt(LocalDateTime.now());
        
        employeeRepository.save(employee);
    }
    
    private Long getCurrentUserId() {
        // 从 SecurityContext 获取当前用户ID
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof UserDetails) {
            // 根据你的实现返回用户ID
            return ((CustomUserDetails) authentication.getPrincipal()).getUserId();
        }
        return null;
    }
}
```

---

## 八、总结

### 8.1 核心要点

1. **重要数据使用软删除**：用户、员工、订单等
2. **添加删除相关字段**：deleted, deleted_at, deleted_by
3. **查询时过滤已删除记录**：使用 Repository 方法
4. **提供恢复功能**：允许管理员恢复误删数据
5. **统一异常处理**：友好的错误提示
6. **性能优化**：使用索引和部分索引

### 8.2 实施步骤

1. ✅ 数据库迁移（添加软删除字段）
2. ✅ 实体类改造（添加字段和注解）
3. ✅ Repository 改造（添加查询方法）
4. ✅ Service 改造（实现软删除逻辑）
5. ✅ 异常处理优化（统一异常处理）
6. ✅ 测试验证（确保功能正常）

### 8.3 注意事项

- ⚠️ 软删除会增加数据库存储空间，需要定期清理
- ⚠️ 查询时需要过滤已删除记录，注意性能
- ⚠️ 外键约束需要考虑软删除的影响
- ⚠️ 统计查询需要明确是否包含已删除数据

---

**文档版本：** v1.0  
**最后更新：** 2025-12-29  
**作者：** AI Assistant






















