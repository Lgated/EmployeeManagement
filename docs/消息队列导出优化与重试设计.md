## 消息队列导出优化与重试设计

> 聚焦几个常见问题：前端轮询是否浪费资源、任务迟迟不完成如何兜底、如何设计重试/死信队列、防止重复轮询的进阶方案，以及代码建议。

---

### 1. 前端轮询 vs. 资源消耗

| 方案               | 优点                            | 缺点                             | 适用场景              |
| ---------------- | ----------------------------- | ------------------------------ | ----------------- |
| 固定间隔轮询（当前方案，2 秒） | 实现简单、无需额外协议                   | 任务久未完成时会持续请求；移动端耗电、PC 跨窗口也会占网络 | 早期版本、任务 10 秒内能完成  |
| 指数退避轮询           | 初始 1 秒，未完成则 2s、4s、8s...直到最大间隔 | 逻辑稍复杂，但能减少长时间任务的请求数            | 导出耗时不稳定、可能 1~2 分钟 |
| WebSocket/SSE 推送 | 服务器主动推送状态                     | 需要保持长连接、部署/运维复杂                | 需要实时反馈、导出频率高      |
| 邮件/站内信通知         | 用户不用守在页面                      | 体验慢，不适合“即点即用”场景                | 极大文件（几百 MB）或定时报表  |

**建议：**在现有轮询基础上，引入“最大轮询次数 + 退避策略”：

```ts
const pollTask = (taskId: number, retry = 0) => {
  const delay = Math.min(2000 * (2 ** retry), 15000) // 2s,4s,8s...15s 上限
  setTimeout(async () => {
    const task = await getExportTask(taskId)
    if (task.status === 'SUCCESS') {
      await downloadExportFile(taskId)
    } else if (task.status === 'FAILED') {
      message.error(task.errorMsg ?? '导出失败')
    } else if (retry < 6) { // 最多 6 次
      pollTask(taskId, retry + 1)
    } else {
      message.warning('导出仍在进行，请稍后手动刷新')
    }
  }, delay)
}
```

这样最多轮询 6 次，总时长约 30 秒；超出后提示用户稍后再试，同时提供“刷新状态”按钮或后台任务列表页。

---

### 2. 任务长时间未完成的兜底

#### 2.1 任务状态页面

新增 `我的导出任务` 页面，展示任务列表（状态、发起时间、文件下载、错误原因）。用户无需一直停留在列表页，可在“任务中心”查看。接口复用 `ExportTaskController.getTask(...)`，再提供分页列表 `GET /api/export-tasks?page=...`。

#### 2.2 后端定时扫描

某些任务可能由于消费者异常/服务器重启导致卡在 `PROCESSING`。增加定时任务：

```java
@Scheduled(fixedDelay = 300000) // 每 5 分钟
public void checkStuckTasks() {
    LocalDateTime expire = LocalDateTime.now().minusMinutes(10);
    List<ExportTask> stuckTasks = exportTaskRepository
        .findByStatusAndUpdatedAtBefore("PROCESSING", expire);
    stuckTasks.forEach(task -> {
        task.setStatus("FAILED");
        task.setErrorMsg("处理超时，请重新导出");
        task.setUpdatedAt(LocalDateTime.now());
        exportTaskRepository.save(task);
    });
}
```

同时在日志或报警里提示开发者排查消费者是否正常。

---

### 3. 死信队列与重试机制

#### 3.1 为什么需要死信队列

当消费者处理失败并抛出异常时，RabbitMQ 会根据配置重新投递或进入死信队列。默认情况下，如果一直失败会不断重试，可能导致“消息风暴”。通过死信队列可以限制重试次数、隔离故障消息。

#### 3.2 基础配置示例

```java
public class ExportMqConfig {
    public static final String EXPORT_DL_EXCHANGE = "export.dl.exchange";
    public static final String EXPORT_DL_QUEUE = "export.dl.queue";
    public static final String EXPORT_DL_ROUTING_KEY = "export.dl.routing";

    @Bean
    public Queue exportQueue() {
        return QueueBuilder.durable(EXPORT_QUEUE)
                .withArgument("x-dead-letter-exchange", EXPORT_DL_EXCHANGE)
                .withArgument("x-dead-letter-routing-key", EXPORT_DL_ROUTING_KEY)
                .build();
    }

    @Bean
    public Queue exportDlQueue() {
        return QueueBuilder.durable(EXPORT_DL_QUEUE).build();
    }

    @Bean
    public DirectExchange exportDlExchange() {
        return new DirectExchange(EXPORT_DL_EXCHANGE);
    }

    @Bean
    public Binding exportDlBinding() {
        return BindingBuilder.bind(exportDlQueue())
                .to(exportDlExchange())
                .with(EXPORT_DL_ROUTING_KEY);
    }
}
```

当 `ExportConsumer` 抛出异常时，消息会进入死信队列。可以再写一个 `ExportDlConsumer`，负责记录日志、发送报警或人工干预。

#### 3.3 自定义重试次数

可以为主队列添加 `x-message-ttl` 与 `x-dead-letter-exchange` 组合实现延迟重试，也可使用 Spring Retry：

```java
@RabbitListener(queues = ExportMqConfig.EXPORT_QUEUE)
@Retryable(
    value = { RuntimeException.class },
    maxAttempts = 3,
    backoff = @Backoff(delay = 2000, multiplier = 2)
)
public void handleExportTask(ExportTaskMessage message) {
    // ...
}

@Recover
public void recover(RuntimeException e, ExportTaskMessage message) {
    log.error("导出任务重试多次仍失败，进入死信流程 taskId={}", message.getTaskId(), e);
    // 更新任务状态为 FAILED，或者发送到死信队列
}
```

---

### 4. 防止重复消费 & 幂等

当前 `ExportConsumer` 已经检查 `status == PENDING` 才处理；可以进一步增加 Redis 或数据库乐观锁防重。同时，`ExportTaskService.create...` 和 `ExportTaskRepository` 内可以增加唯一索引（如 `task_type + created_by + params + created_at`）以防短时间内重复提交。

---

### 5. 结合业务的建议

1. **前端体验**  
   - 默认轮询 + 指数退避  
   - 任务中心列表  
   - 失败/长时间无响应时提示“系统正在生成，请稍后到任务中心查看”

2. **后端稳定性**  
   - 消息转换器采用 `Jackson2JsonMessageConverter`（已配置）  
   - `ExportTask.params` 使用 JSONB 类型（已修复）  
   - 消费者增加 `maxAttempts`、`@Recover`、死信队列  
   - 定时任务扫描 `PROCESSING` 超时记录

3. **扩展方向**  
   - 生成完成后写入对象存储（OSS/S3），返回带签名的下载 URL，前端无需再经过服务端中转  
   - 对大型导出任务采用分批生成（分页写多个 sheet 或 zip）  
   - 任务队列按类型拆分（员工导出 vs 用户导出）以避免互相阻塞

---

### 6. 示例：任务表字段扩展

```sql
ALTER TABLE export_task
    ADD COLUMN retry_count INTEGER DEFAULT 0,
    ADD COLUMN last_error VARCHAR(255);
```

消费者处理失败时：

```java
task.setRetryCount(task.getRetryCount() + 1);
task.setLastError(e.getMessage());
if (task.getRetryCount() >= 3) {
    task.setStatus("FAILED");
} else {
    task.setStatus("PENDING");
    // 重新发送消息或等待定时任务重送
}
exportTaskRepository.save(task);
```

相比 MQ 重试，这种“数据库驱动”方式更易观察和控制。

---

### 7. 知识点速查

| 名称 | 作用 | 关键配置 |
|------|------|----------|
| Dead-Letter Exchange (DLX) | 消费失败或 TTL 到期后转移消息 | `x-dead-letter-exchange`, `x-dead-letter-routing-key` |
| Message TTL | 限制消息在队列中的存活时间 | `x-message-ttl` |
| 延迟队列 | 通过 TTL + DLX 组合实现 | 主队列 TTL -> 死信交换机 -> 重新投递 |
| RetryTemplate / @Retryable | 消费端代码级重试 | `@Retryable(maxAttempts, backoff)` |
| 幂等 | 防止重复消息造成重复导出 | 通过任务状态 + 唯一索引 + Redis 锁 |
| 指数退避 | 客户端轮询间隔逐步增大，减轻压力 | 2^n * baseDelay，设上限 |

---

### 8. 推荐实施顺序

1. **短期（一天内）**：  
   - 前端轮询加总次数限制和退避逻辑  
   - 后端新增任务中心列表 + 手动刷新  

2. **中期（一周内）**：  
   - 添加死信队列 + `@Retryable`，记录 retry_count  
   - 定时扫描 `PROCESSING` 超时任务  

3. **长期**：  
   - 对接对象存储，提供下载链接  
   - 引入消息推送（WebSocket/SSE）或通知系统  
   - 支持导出任务的权限控制与审计日志

按照上面的路线逐步增强，就能既保证系统稳定又兼顾用户体验。若还需要 demo 代码或配置示例，可以再具体展开某一部分。





